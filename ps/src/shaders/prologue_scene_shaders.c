#include "ps_shader.h"

#define PS_SHADER_PROLOGUE_PUSH_CONSTANTS \
"struct PushConstantData {\n" \
"   float windowWidth;\n" \
"   float windowHeight;\n" \
"   float sphereRadius;\n" \
"   float time;\n" \
"   vec3 spherePosition;\n" \
"   vec3 cameraPosition;\n" \
"   float rotation;\n" \
"};\n" \
"layout(push_constant) uniform PushConstants {\n" \
"   PushConstantData data;\n" \
"} pushConstants;\n"

const char* psShader_PrologueVertex =
    "#version 450\n"
    "#pragma shader_stage(vertex)\n"
    "layout(location = 0) out vec2 outUV;\n"
    PS_SHADER_PROLOGUE_PUSH_CONSTANTS
    "const vec2 positions[6] = vec2[](\n"
    "    vec2(-1.0, -1.0),\n"
    "    vec2(-1.0, 1.0),\n"
    "    vec2(1.0, 1.0),\n"
    "    vec2(-1.0, -1.0),\n"
    "    vec2(1.0, 1.0),\n"
    "    vec2(1.0, 0.0)\n"
    ");\n"
    "void main() {\n"
    "    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);\n"
    "    outUV = positions[gl_VertexIndex] * 0.5 + 0.5;\n"
    "}\n";

const char* psShader_PrologueFragment =
    "#version 450\n"
    "#pragma shader_stage(fragment)\n"
    "precision highp float;\n"
    "layout(location = 0) in vec2 inUV;\n"
    "layout(location = 0) out vec4 outColor;\n"
    PS_SHADER_PROLOGUE_PUSH_CONSTANTS
    PS_SHADER_ACES
    "\n"
    "// Signed Distance Function for a sphere\n"
    "float sdSphere(vec3 p, float radius) {\n"
    "    return length(p) - radius;\n"
    "}\n"
    "\n"
    "// Rotation matrix around the Y axis\n"
    "mat3 rotateY(float angle) {\n"
    "    float s = sin(angle);\n"
    "    float c = cos(angle);\n"
    "    return mat3(\n"
    "        c, 0.0, s,\n"
    "        0.0, 1.0, 0.0,\n"
    "        -s, 0.0, c\n"
    "    );\n"
    "}\n"
    "\n"
    "// Main scene SDF function\n"
    "float map(vec3 p) {\n"
    "    // Apply rotation\n"
    "    p = rotateY(pushConstants.data.rotation) * p;\n"
    "    // Move the point relative to the sphere position\n"
    "    vec3 spherePos = p - pushConstants.data.spherePosition;\n"
    "    // Calculate distance to sphere\n"
    "    return sdSphere(spherePos, pushConstants.data.sphereRadius);\n"
    "}\n"
    "\n"
    "// Function to calculate normal at a point using central differences\n"
    "vec3 calcNormal(vec3 p) {\n"
    "    const float eps = 0.001;\n"
    "    const vec2 h = vec2(eps, 0.0);\n"
    "    return normalize(vec3(\n"
    "        map(p + h.xyy) - map(p - h.xyy),\n"
    "        map(p + h.yxy) - map(p - h.yxy),\n"
    "        map(p + h.yyx) - map(p - h.yyx)\n"
    "    ));\n"
    "}\n"
    "\n"
    "// Main ray marching function\n"
    "float rayMarch(vec3 ro, vec3 rd, float maxDist) {\n"
    "    float t = 0.0;\n"
    "    for (int i = 0; i < 100; i++) { // Maximum 100 steps\n"
    "        vec3 p = ro + rd * t;\n"
    "        float d = map(p);\n"
    "        if (d < 0.001) return t; // Hit\n"
    "        if (t > maxDist) break;  // Missed, too far\n"
    "        t += d; // Safe step\n"
    "    }\n"
    "    return -1.0; // Didn't hit anything\n"
    "}\n"
    "\n"
    "// Lighting calculation\n"
    "vec3 lighting(vec3 p, vec3 normal) {\n"
    "    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n"
    "    vec3 baseColor = vec3(0.9, 0.2, 0.3); // Reddish color\n"
    "    \n"
    "    // Add time-based color variation\n"
    "    baseColor = mix(baseColor, vec3(0.3, 0.2, 0.9), 0.5 + 0.5 * sin(pushConstants.data.time * 0.5));\n"
    "    \n"
    "    // Ambient light\n"
    "    float ambient = 0.1;\n"
    "    \n"
    "    // Diffuse light\n"
    "    float diff = max(dot(normal, lightDir), 0.0);\n"
    "    \n"
    "    // Specular highlight\n"
    "    vec3 viewDir = normalize(pushConstants.data.cameraPosition - p);\n"
    "    vec3 reflectDir = reflect(-lightDir, normal);\n"
    "    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n"
    "    vec3 specular = vec3(0.5) * spec;\n"
    "    \n"
    "    return baseColor * (ambient + diff) + specular;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    // Screen coordinates centered at origin\n"
    "    vec2 uv = inUV * 2.0 - 1.0;\n"
    "    uv.x *= pushConstants.data.windowWidth / pushConstants.data.windowHeight;\n"
    "    \n"
    "    // Camera setup\n"
    "    vec3 ro = pushConstants.data.cameraPosition; // Ray origin (camera position)\n"
    "    vec3 rd = normalize(vec3(uv, 1.0)); // Ray direction\n"
    "    \n"
    "    // Apply camera rotation\n"
    "    rd = rotateY(pushConstants.data.rotation) * rd;\n"
    "    \n"
    "    // Ray marching\n"
    "    float t = rayMarch(ro, rd, 20.0);\n"
    "    \n"
    "    if (t > 0.0) {\n"
    "        // We hit something\n"
    "        vec3 p = ro + rd * t; // Hit position\n"
    "        vec3 normal = calcNormal(p); // Surface normal\n"
    "        \n"
    "        // Calculate lighting\n"
    "        vec3 color = lighting(p, normal);\n"
    "        \n"
    "        // Apply tone mapping\n"
    "        color = aces(color);\n"
    "        \n"
    "        outColor = vec4(color, 1.0);\n"
    "    } else {\n"
    "        // Background gradient\n"
    "        vec3 gradientStart = vec3(0.1, 0.12, 0.2); // Dark blue\n"
    "        vec3 gradientEnd = vec3(0.3, 0.15, 0.4);   // Purple\n"
    "        float t = 0.5 + 0.5 * uv.y; // Gradient factor based on y coordinate\n"
    "        vec3 bgColor = mix(gradientStart, gradientEnd, t);\n"
    "        \n"
    "        // Add some twinkling stars\n"
    "        vec2 seed = uv + vec2(pushConstants.data.time * 0.1, sin(pushConstants.data.time * 0.2));\n"
    "        float starIntensity = fract(sin(dot(floor(seed * 500.0), vec2(12.9898, 78.233))) * 43758.5453);\n"
    "        starIntensity = pow(starIntensity, 20.0) * 2.0;\n"
    "        bgColor += vec3(starIntensity);\n"
    "        \n"
    "        outColor = vec4(bgColor, 1.0);\n"
    "    }\n"
    "}\n";